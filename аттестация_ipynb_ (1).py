# -*- coding: utf-8 -*-
"""Аттестация.ipynb"

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1WgiGq5snABcjGB3Aj6J7vv9qkGPiix86

# Covid-19 forecasting

## Введение. Постановка целей и задач.

COVID-19 - это вызывающий заболевание штамм коронавируса, появившийся в декабре 2019 года и приведший к продолжающейся глобальной пандемии. Возможность предвидеть путь пандемии имеет решающее значение. Это важно для того, чтобы определить, как бороться, и отследить его распространение.

Целью данной работы является анализ данных о заболеваемости за определнный период в выбранной стране и построение прогностической модели, которую можно обучить преобразованию набора входных данных.

Задачи исследования:

1.   Провести анализ данных о заболеваемости;
2.   Предложить и настроить прогностическую модель;
3.   Выполнить прогноз и сравнить результаты с новой статистикой (полученной после 5 апреля 2021 года);

## Импорт библиотек, ознакомление с данными.

### Импорт Датафрейма, библиотек, написание функций.

Импортируем библиотеки:
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns

"""Считываем исходные датасеты:"""

df = pd.read_csv('KSA.csv')

df1 = pd.read_csv('owid-covid-data.csv')
df1

df2 = pd.read_csv('riyadh.csv')

"""### Знакомство с данными.

Для анализа мы выбрали Россию.

Временной период выбираем с 1 ноября 2021 года (включистельно) по 1 декабря 2021.

Для удобства выводим первые 5 строчек.
"""

Russia = df1[df1['location'] == 'Russia']
period = Russia.query("'2021-11-01' <= date < '2021-12-01'")
period.head(5)

"""**Опишем необходимые для анализа столбцы:**


*   iso_code - часть стандарта ISO 3166, содержащая коды названий стран;
*   continent - континент;
*   location - страна;
*   date - дата;
*   total_cases - количество заболевших за весь период на определенную дату;
*   new_cases - количество новых случаев заболеваний;
*   total_deaths - количество смертей за весь период на определенную дату;
*   new_deaths - количество смертей за определенный день;



"""

# Посмотрим на то, как росло общее количество смертей каждый день; 
plt.figure(figsize=(35,5), dpi=100)
plt.plot(period.date, period.total_deaths, color='blue',alpha=0.4)
plt.title("общее количество смертей")
plt.xlabel("date")
plt.ylabel("total_deaths")

"""Проанализировав график, можно сказать, что с 1 ноября 2021 по 1 декабря 2021 общее количество смертей линейно увеличивалось на протяжении всего периода."""

# Посмотрим, как изменялось количество новых смертей каждый день; 
plt.figure(figsize=(35,5), dpi=100)
plt.plot(period.date,period.new_deaths, color='blue',alpha=0.4)
plt.title("количество новых смертей")
plt.xlabel("date")
plt.ylabel("new_deaths")

"""Проанализировав график, можно сказать, что с 1 ноября 2021 по 1 декабря 2021 количество новый смертей увеличилось за весь рассматриваемый период. 

Если рассматривать весь период, рассматриваемый график показывает плохую тенденцию. Но, если рассматривать отдельные даты, можно заметить, что в некоторые дни происходит значительное уменьшение количества смертей. 
"""

# Посмотрим на то, как росло общее количество заболевших каждый день; 
plt.figure(figsize=(35,5), dpi=100)
plt.plot(period.date, period.total_cases, color='blue',alpha=0.4)
plt.title("общее количество заболевших")
plt.xlabel("date")
plt.ylabel("total_cases")

"""Проанализировав график, можно сказать, что с 1 ноября 2021 по 1 декабря 2021 общее количество заболевших линейно увеличивалось на протяжении всего периода."""

# Посмотрим,как изменялось количество новых случаев заболеваний каждый день; 
plt.figure(figsize=(35,5), dpi=100)
plt.plot(period.date, period.new_cases, color='blue',alpha=0.4)
plt.title("количество новых случаев заболеваний")
plt.xlabel("date")
plt.ylabel("new_cases")

"""Проанализировав график, можно сказать, что с 1 ноября 2021 по 1 декабря 2021 количество новый случаев заболеваний уменьшилось за весь рассматриваемый период.

Если рассматривать весь период, рассматриваемый график показывает отличную тенденцию. Но, если рассматривать отдельные даты, можно заметить, что в некоторые дни происходит увеличение количества случаев новых заболеваний.

## Предобработка данных

### Фильтрация данных

Для того, чтобы нам в дальнейшем было удобнее работать, мы из общей таблицы выберем только те столбцы, которые понабодятся для анализа.
"""

filtr = period[['iso_code','continent','location','date','new_cases','total_cases','total_deaths', 'new_deaths']]
filtr.head(5)

"""### Обработка пропусков

Мы работаем в задаче с временным промежутком, и нам важно, чтобы не было отсутствующих дат:
"""

filtr['date']

"""В выбранном нами временном промежутке пропусков нет. Можем продолжать работать с данным периодом.

### Вывод по этапу.

В данном разделе мы познакомились с данными. 

Выбрали страну, период, с которыми в дальнейшем будем работать. 

Построили графики и проанализировали, как изменилялись за определенный период следующие показатели:

*   total_cases - количество заболевших за весь период на определенную дату;
*   new_cases - количество новых случаев заболеваний;
*   total_deaths - количество смертей за весь период на определенную дату;
*   new_deaths - количество смертей за определенный день;

Проверили на пропуски наш временной период. И удобства выбрали только те столбцы, которые понадобятся для анализа.

## EDA или разведочный анализ данных.

В данном блоке наша задача - познакомиться "поближе" с данными, которыми мы располагаем.

Для начала посмотрим на статистику по выбранным нами раннее столбцам:
"""

filtr.describe()

"""Посмотрим столбец с датами и индексами:"""

filtr['date']

"""Построим графическое представление всех столбцов:"""

# Посмотрим на то, как росло общее количество смертей каждый день; 
plt.figure(figsize=(7,2), dpi=100)
plt.plot(period.total_deaths, color='blue',alpha=0.4)

# Посмотрим, как изменялось количество новых смертей каждый день; 
plt.figure(figsize=(7,2), dpi=100)
plt.plot(period.new_deaths, color='blue',alpha=0.4)

# Посмотрим на то, как росло общее количество заболевших каждый день; 
plt.figure(figsize=(7,2), dpi=100)
plt.plot( period.total_cases, color='blue',alpha=0.4)

# Посмотрим,как изменялось количество новых случаев заболеваний каждый день; 
plt.figure(figsize=(7,2), dpi=100)
plt.plot(period.new_cases, color='blue',alpha=0.4)

"""Рассмотрим первый и второй график.

Посмотрим на то, как линейно росло общее количество смертей и как изменялось количество новых смертей каждый день. 

Мне кажется, что для того, чтобы определить будет ли смертность увеличиваться или уменьшаться в России необходимо рассматривать либо период, который затрагивает временной промежуток побольше, либо все страны в совокупности (особенно рассматривать "соседние" страны).

Рассмотрим третий и четвертый график.

Посмотрим на то, как линейно росло общее количество заболевших и как изменялось количество новых случаев заболеваний каждый день. 

В связи с массовой вакцинацией страны можно заметить скачкообразный спад количества новых случаев заболеваний. Предполаю, что данная тенденция будет только улучшаться и мы можем по данному графику сделать определенный вывод, что не скажешь об общем количестве заболевших, которое растет линейно на протяжении всего периода. По рассматриваемому графику сложно дать ответ, что будет, если мы захотим понять, что произойдет в будущем с общим количеством заболевших в России.

## Построение моделей, анализ результатов.

### Разделим датасет на тренировочную и тестовую (валидационную) выборки, проверим на статичность
"""

filtr.columns

X, y = filtr[[ 'new_cases', 'total_cases','total_deaths', 'new_deaths']], filtr['date']

X.head()

y.head()

# Функции для разделения данных на данные для обучения и тестирования
from sklearn.model_selection import train_test_split

# Разделим данные на данные для обучения и тестирования
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)

X_train.head()

X_test.head()

y_train.head()

from sklearn.linear_model import LogisticRegression

model = LogisticRegression()

X_train 
model.fit(X_train, y_train)

# Оцениваем качетво
from sklearn.metrics import accuracy_score

# Оцениваем качество на выборке обучения
accuracy_score(y_train, model.predict(X_train))

# Оцениваем качество на выборке тестирования
accuracy_score(y_train, model.predict(X_train))

# Модель DecisionTreeClassifier обучим на тех же данных и посмотрим качество

from sklearn.tree import DecisionTreeClassifier

model_tree = DecisionTreeClassifier()

model_tree.fit(X_train,y_train)

accuracy_score(y_test, model_tree.predict(X_test))

"""### Построим графики автокорреляции и частичной автокорреляции, разобьем на сезонность и тренд."""

import numpy as np

# импорт SARIMAX 
from statsmodels.tsa.statespace.sarimax import SARIMAX

from statsmodels.graphics.tsaplots import plot_acf,plot_pacf # для определения (p,q) 
from statsmodels.tsa.seasonal import seasonal_decompose      # для ETS графиков

# метрики
from sklearn.metrics import mean_squared_error
from statsmodels.tools.eval_measures import rmse

import warnings
warnings.filterwarnings("ignore")

import matplotlib.pyplot as plt

filtr['mean50'] = filtr['new_cases'].rolling(window=50).mean()
filtr['mean5'] = filtr['new_cases'].rolling(window=5).mean()

plt.figure(figsize=(35,5), dpi=160)
plt.plot(filtr.new_cases, color='blue',alpha=0.4)
plt.plot(filtr.mean50, color='red',alpha=0.4)
plt.plot(filtr.mean5, color='green',alpha=0.4)
plt.show()

filtr.corr()

r = seasonal_decompose(filtr['new_cases'])

r.trend.plot()
r.seasonal.plot()

(r.trend + r.seasonal).plot()

plot_acf(filtr['new_cases'])

plot_pacf(filtr['new_cases'])

"""### Примененим 1 способа прогнозирования."""

df5 = pd.read_csv('owid-covid-data.csv', encoding='windows-1251', index_col='date',parse_dates=True) 
Russia1 = df5[df5['location'] == 'Russia']
period1 = Russia1.query("'2021-10-01' <= date < '2021-12-01'")
df6 = period1[['new_cases']]
#df6.index.freq = 'MS'

df6.plot()

train = df6.iloc[:len(df6)-12]
test = df6.iloc[len(df6)-12:]

"""Используем первый метод прогнозирования."""

from statsmodels.tsa.statespace.sarimax import SARIMAX

"""Инициализируем и обучаем модель."""

model1 = SARIMAX(df6['new_cases'], order=(1, 1, 2), seasonal_order=(1, 0, 1, 12))
results = model1.fit()

"""Построем предсказания."""

start=len(train)
end=len(train)+len(test)-1
predictions = results.predict(start=start, end=end, dynamic=False, typ='levels').rename(' Predictions SARIMAX(1, 1, 2)x(1, 0, [1], 12)')

plt.figure(figsize=(35,5), dpi=160)
plt.plot(train, label='train')
plt.plot(test, label='test')
plt.plot(predictions, label='prediction')
plt.legend()
plt.show()

plt.figure(figsize=(7,3), dpi=160)
plt.plot(test, label='test')
plt.plot(predictions, label='prediction')
plt.legend()
plt.show()

from sklearn.metrics import mean_absolute_error, mean_absolute_percentage_error, mean_squared_error

print('Рассчет точности полученного прогноза.')
print('MAE:', mean_absolute_error(test, predictions))
print('MAPE:', mean_absolute_percentage_error(test, predictions))
print('MSE:', mean_squared_error(test, predictions))

"""### Применим 2 способ прогнозирования"""

from statsmodels.tsa.holtwinters import SimpleExpSmoothing   
from statsmodels.tsa.holtwinters import ExponentialSmoothing

model_hw = ExponentialSmoothing(df6,trend='add',seasonal='add',seasonal_periods=12).fit()

predictions_hw = model_hw.predict(start=start, end=end)

plt.figure(figsize=(7,3), dpi=160)
plt.plot(test, label='test')
plt.plot(predictions_hw, label='prediction')
plt.legend()
plt.show()

print('Рассчет точности полученного прогноза.')
print('MAE:', mean_absolute_error(test, predictions_hw))
print('MAPE:', mean_absolute_percentage_error(test, predictions_hw))
print('MSE:', mean_squared_error(test, predictions_hw))

"""## Выводы

Алгоритм действий, который мы будем использовать при прогнозировании:

*   Создаем модель
*   Обучаем модель
*   Создаем прогноз
*   Сравниваем прогноз и предсказание
*   Рассчитываем качество полученной модели и прогноза

Для того, чтобы понять подходит ли модель. Мы используем 
следующие методы рассчета ошибки:

MAPE - средняя абсолютная ошибка в процентах.

RMSE - квадратный корень из среднеквадратичной ошибки.

MSE - среднеквадратичный корень (связан с RMSE).

1 способ прогнозирования показал следующие результаты:

*   MAE: 661.0823844312278
*   MAPE: 0.0198836730551333
*   MSE: 708546.0195614834

2 способ прогнозирования показал следующие результаты:

*   MAE: 869.6671281196064
*   MAPE: 0.02580314465957553
*   MSE: 1160032.8080152974

Сравнив полученные метрики с ошибками понимаем, что первая модель точнее всего создает прогноз.

Прогноз, который мы получили не самый точный. С учетом того, насколько сложен процесс распространения коронавирусной инфекции, можно с уверенностью сказать, что обычный анализ временного ряда вряд ли даст очень хороший результат. Иначе бы у ученых-прогнозистов не было проблем с предзказанием коронавирусной инфекии

Презентация:
https://docs.google.com/presentation/d/1RHK8OWkg_GUEqcIloo9pJ8QA4GGHGyEg/edit?usp=sharing&ouid=103779134406038086064&rtpof=true&sd=true
"""